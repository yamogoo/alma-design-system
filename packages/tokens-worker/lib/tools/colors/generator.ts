import fs from 'node:fs';
import Color from 'color';

import type {
  ColorsGeneratorOptions,
  MainColor,
  DerivativeColor,
  DerivativeColors,
} from './types.js';
import {
  toKebab,
  hasField,
  getField,
  isColorish,
  ensureDirForFile,
  resolveOutputPaths,
} from './utils.js';

export const generateDerivativeColors = (color: MainColor): DerivativeColors => {
  const tempColors: DerivativeColors = [];
  const { id, name: rootName, value: rootValue, step, prefix, separator } = color;

  const colorLightnessFactor = 100 / (step + 2);

  for (let i = 0; i <= step; i++) {
    const increment = Math.round(1000 - (1000 / step) * i);
    const fullName = `${prefix}${rootName}${separator}${increment}`;

    const colorInstance = Color(rootValue).lightness((i + 1) * colorLightnessFactor);

    const value = colorInstance.hex();
    const lightness = colorInstance.lightness();
    const isLight = colorInstance.isLight();

    const derivative: DerivativeColor = {
      id: `${id}${i}`,
      name: prefix,
      fullName,
      value,
      increment,
      lightness,
      isLight,
    };

    tempColors.push(derivative);
  }

  return tempColors.sort((a, b) => a.increment - b.increment);
};

const buildDerivativesCollector = (step: number) => {
  const tokenMap: Record<string, { $value: string; $type: 'color'; $unit: 'hex' }> = {};

  const addDerivatives = (baseName: string, baseColor: string) => {
    const colorDef: MainColor = {
      id: baseName,
      name: baseName,
      value: baseColor,
      step,
      prefix: '',
      separator: '-',
    };
    const generated = generateDerivativeColors(colorDef);
    for (const c of generated) {
      tokenMap[c.fullName] = { $value: c.value, $type: 'color', $unit: 'hex' };
    }
  };

  const traverse = (obj: any, pathAcc: string[] = []): void => {
    if (obj == null || typeof obj !== 'object') return;

    if (hasField(obj, 'value')) {
      const rawVal = getField<string>(obj, 'value');
      if (isColorish(rawVal)) {
        const baseName = pathAcc.map(toKebab).join('-');
        addDerivatives(baseName, rawVal);
      }
    }

    for (const [key, value] of Object.entries(obj)) {
      // пропускаем сервисные поля, кроме $value
      if (key.startsWith('$') && key !== '$value') continue;

      if (typeof value === 'object' && value !== null) {
        traverse(value, [...pathAcc, key]);
      } else if (key === 'value' && isColorish(value)) {
        const baseName = pathAcc.map(toKebab).join('-');
        addDerivatives(baseName, value);
      }
    }
  };

  return { tokenMap, traverse };
};

const writeOutput = (
  tokenMap: Record<string, { $value: string; $type: 'color'; $unit: 'hex' }>,
  outDir: string,
  comment: string,
) => {
  const { mainPath } = resolveOutputPaths(outDir);

  ensureDirForFile(mainPath);

  const json = JSON.stringify(tokenMap, null, 2);
  fs.writeFileSync(mainPath, json);
};

export const generateColorsFromFile = (opts: ColorsGeneratorOptions): void => {
  const {
    source,
    outDir,
    step = 40,
    comment = `# ${outDir} Generated by ColorsGenerator. !! DO NOT MODIFY THIS FILE !!\n`,
  } = opts;

  if (!/\.json$/i.test(source)) {
    throw new Error('Invalid source file: must be a .json file.');
  }

  const raw = fs.readFileSync(source, 'utf-8');
  const parsed = JSON.parse(raw);

  const { tokenMap, traverse } = buildDerivativesCollector(step);
  traverse(parsed);

  writeOutput(tokenMap, outDir, comment);
};
