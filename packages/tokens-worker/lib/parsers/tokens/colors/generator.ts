import fs from 'node:fs';
import Color from 'color';

import type {
  ColorsGeneratorOptions,
  MainColor,
  DerivativeColor,
  DerivativeColors,
} from './types.js';
import {
  toKebab,
  hasField,
  getField,
  isColorish,
  ensureDirForFile,
  resolveOutputPaths,
} from './utils.js';

export const generateDerivativeColors = (color: MainColor): DerivativeColors => {
  const tempColors: DerivativeColors = [];
  const { id, name: rootName, value: rootValue, step, prefix, separator } = color;

  const colorLightnessFactor = 100 / (step + 2);

  for (let i = 0; i <= step; i++) {
    const increment = Math.round(1000 - (1000 / step) * i);
    const fullName = `${prefix}${rootName}${separator}${increment}`;

    const colorInstance = Color(rootValue).lightness((i + 1) * colorLightnessFactor);

    const value = colorInstance.hex();
    const lightness = colorInstance.lightness();
    const isLight = colorInstance.isLight();

    const derivative: DerivativeColor = {
      id: `${id}${i}`,
      name: prefix,
      fullName,
      value,
      increment,
      lightness,
      isLight,
    };

    tempColors.push(derivative);
  }

  return tempColors.sort((a, b) => a.increment - b.increment);
};

const buildDerivativesCollector = (step: number) => {
  const flatMap: Record<string, string> = {};
  const tokenMap: Record<string, { $value: string; $type: 'color' }> = {};

  const addDerivatives = (baseName: string, baseColor: string) => {
    const colorDef: MainColor = {
      id: baseName,
      name: baseName,
      value: baseColor,
      step,
      prefix: '',
      separator: '-',
    };
    const generated = generateDerivativeColors(colorDef);
    for (const c of generated) {
      flatMap[c.fullName] = c.value;
      tokenMap[c.fullName] = { $value: c.value, $type: 'color' };
    }
  };

  const traverse = (obj: any, pathAcc: string[] = []): void => {
    if (obj == null || typeof obj !== 'object') return;

    if (hasField(obj, 'value')) {
      const rawVal = getField<string>(obj, 'value');
      if (isColorish(rawVal)) {
        const baseName = pathAcc.map(toKebab).join('-');
        addDerivatives(baseName, rawVal);
      }
    }

    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith('$') && key !== '$value') continue;

      if (typeof value === 'object' && value !== null) {
        traverse(value, [...pathAcc, key]);
      } else if (key === 'value' && isColorish(value)) {
        const baseName = pathAcc.map(toKebab).join('-');
        addDerivatives(baseName, value);
      }
    }
  };

  return { flatMap, tokenMap, traverse };
};

const writeOutputs = (
  flatMap: Record<string, string>,
  tokenMap: Record<string, { $value: string; $type: 'color' }>,
  outDir: string,
  comment: string,
  writeMarkdownFiles: boolean,
) => {
  const { mainPath, underscoredPath, mainMd, underscoredMd } = resolveOutputPaths(outDir);

  ensureDirForFile(mainPath);
  ensureDirForFile(underscoredPath);

  fs.writeFileSync(mainPath, JSON.stringify(flatMap, null, 2));
  fs.writeFileSync(underscoredPath, JSON.stringify(tokenMap, null, 2));

  if (writeMarkdownFiles) {
    const sortedEntries = Object.entries(flatMap).sort(([a], [b]) => a.localeCompare(b));
    const markdownContent = [
      comment,
      '| Token | Value |',
      '| ----- | ----- |',
      ...sortedEntries.map(
        ([key, val]) => `| \`${key}\` | <span style="background:${val};padding:0.2rem">${val}</span> |`,
      ),
      '',
    ].join('\n');

    ensureDirForFile(mainMd);
    ensureDirForFile(underscoredMd);
    fs.writeFileSync(mainMd, markdownContent);
    fs.writeFileSync(underscoredMd, markdownContent);
  }
};

export const generateColorsFromFile = (opts: ColorsGeneratorOptions): void => {
  const {
    source,
    outDir,
    step = 20,
    comment = `# ${outDir} Generated by ColorsGenerator. !! DO NOT MODIFY THIS FILE !!\n`,
    writeMarkdownFiles = false,
  } = opts;

  if (!/\.json$/i.test(source)) {
    throw new Error('Invalid source file: must be a .json file.');
  }

  const raw = fs.readFileSync(source, 'utf-8');
  const parsed = JSON.parse(raw);

  const { flatMap, tokenMap, traverse } = buildDerivativesCollector(step);
  traverse(parsed);

  writeOutputs(flatMap, tokenMap, outDir, comment, writeMarkdownFiles);
};
