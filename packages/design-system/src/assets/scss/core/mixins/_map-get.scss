// Portions of this file were developed with the assistance of AI tools.

@use "sass:map";
@use "sass:list";
@use "sass:string";
@use "sass:meta";
@use "sass:math";

@use "../../abstracts/breakpoints" as *;

// Service field helpers.

@function _svc-alternates($key) {
  @if string.slice($key, 1, 1) == "$" {
    @return ($key, string.slice($key, 2));
  }
  @return ($key, "$#{$key}");
}

@function map-get-any($map, $keys...) {
  @each $k in $keys {
    @if map.has-key($map, $k) {
      @return map.get($map, $k);
    }
  }
  @return null;
}

@function map-get-svc($map, $key) {
  $alts: _svc-alternates($key);
  @return map-get-any($map, $alts...);
}

// String utilities.

@function str-split($string, $delimiter: ".") {
  $result: ();
  $current: "";
  $length: string.length($string);

  @for $i from 1 through $length {
    $ch: string.slice($string, $i, $i);
    @if $ch == $delimiter {
      $result: list.append($result, $current);
      $current: "";
    } @else {
      $current: "#{$current}#{$ch}";
    }
  }
  @return list.append($result, $current);
}

// Value resolvers.

@function get-value($map-or-value, $path: null) {
  @if $path == null {
    @return $map-or-value;
  }

  $keys: str-split($path, ".");
  $value: $map-or-value;

  @each $raw-key in $keys {
    @if meta.type-of($value) != "map" {
      @error "get-value(): '#{$raw-key}' not in non-map at '#{$path}'.";
    }

    $next: map.get($value, $raw-key);
    @if $next == null {
      $next: map-get-svc($value, $raw-key);
    }
    @if $next == null {
      @error "get-value(): key '#{$raw-key}' not found. Available: #{map.keys($value)}";
    }

    $value: $next;
  }

  @return $value;
}

@function get($map-or-value, $path: null) {
  $val: get-value($map-or-value, $path);

  @if $path != null {
    $keys: str-split($path, ".");
    @if list.index($keys, "respond") or list.index($keys, "$respond") {
      @return $val;
    }
  }

  @if meta.type-of($val) == "map" {
    $maybe: map-get-svc($val, "value");
    @if $maybe != null {
      @return $maybe;
    }
  }

  @return $val;
}

// Breakpoint helpers.

@function _bp-raw($name) {
  $raw: map.get($breakpoints, $name);
  @if $raw == null {
    @error "Breakpoint '#{$name}' not found in $breakpoints.";
  }
  @return $raw;
}

@function bp-value($name) {
  $raw: _bp-raw($name);
  @return if(meta.type-of($raw) == "map", map-get-svc($raw, "value"), $raw);
}

@function bp-next($name) {
  $keys: map.keys($breakpoints);
  $idx: list.index($keys, $name);
  @if $idx == null {
    @error "bp-next(): '#{$name}' not found in $breakpoints.";
  }
  @if $idx == list.length($keys) {
    @return null;
  }
  @return list.nth($keys, $idx + 1);
}

// Media mixins.

@mixin respond-above($bp) {
  @media (min-width: bp-value($bp)) {
    @content;
  }
}

@mixin respond-below($bp) {
  $max: bp-value($bp) - 0.02px;
  @media (max-width: $max) {
    @content;
  }
}

@mixin respond-at($bp) {
  $min: bp-value($bp);
  $next: bp-next($bp);
  @if $next == null {
    @media (min-width: $min) {
      @content;
    }
  } @else {
    $max: bp-value($next) - 0.02px;
    @media (min-width: $min) and (max-width: $max) {
      @content;
    }
  }
}

@mixin respond-between($from, $to) {
  $min: bp-value($from);
  $max: bp-value($to) - 0.02px;
  @media (min-width: $min) and (max-width: $max) {
    @content;
  }
}

// Value helpers.

@function _unwrap($maybe) {
  @if meta.type-of($maybe) == "map" {
    $v: map-get-svc($maybe, "value");
    @return if($v != null, $v, $maybe);
  }
  @return $maybe;
}

@function _prop-from-node($node, $css-prop) {
  @if meta.type-of($node) != "map" {
    @return _unwrap($node);
  }

  $sub: map.get($node, $css-prop);
  @if $sub == null {
    $sub: map-get-svc($node, $css-prop);
  }
  @if $sub != null {
    @return _unwrap($sub);
  }

  @return _unwrap($node);
}

// Universal mixin with auto-respond support.

@mixin apply-token($tokens, $css-prop, $path) {
  // Base property
  #{$css-prop}: get($tokens, $path);

  $node: get-value($tokens, $path);
  @if meta.type-of($node) != "map" {
    @content;
  }

  $respond: map-get-svc($node, "respond");
  @if $respond == null or meta.type-of($respond) != "map" {
    @content;
  }

  // At mode applies styles within a specific range window.
  $at: map.get($respond, at);
  @if $at != null and meta.type-of($at) == "map" {
    @each $bp, $block in $at {
      $val: _prop-from-node($block, $css-prop);
      @include respond-at($bp) {
        #{$css-prop}: $val;
      }
    }
  }

  // Above mode applies from the breakpoint and up.
  $above: map.get($respond, above);
  @if $above != null and meta.type-of($above) == "map" {
    @each $bp, $block in $above {
      $val: _prop-from-node($block, $css-prop);
      @include respond-above($bp) {
        #{$css-prop}: $val;
      }
    }
  }

  // Below mode applies below the breakpoint.
  $below: map.get($respond, below);
  @if $below != null and meta.type-of($below) == "map" {
    @each $bp, $block in $below {
      $val: _prop-from-node($block, $css-prop);
      @include respond-below($bp) {
        #{$css-prop}: $val;
      }
    }
  }

  // Between mode applies between two breakpoints.
  $between: map.get($respond, between);
  @if $between != null and meta.type-of($between) == "map" {
    @each $range, $block in $between {
      $dash: string.index($range, "-");
      @if $dash == null {
        @warn "apply-token(): invalid between range `#{$range}` at `#{$path}`.";
      } @else {
        $from: string.slice($range, 1, $dash - 1);
        $to: string.slice($range, $dash + 1);
        $val: _prop-from-node($block, $css-prop);
        @include respond-between($from, $to) {
          #{$css-prop}: $val;
        }
      }
    }
  }
}
